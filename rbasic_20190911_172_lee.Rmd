---
title: "0911 Assignment"
output: html_notebook
---

# 4 Programming basics

We can use R as a powerful facility to analize some data.
Sinse, R is a programming language fundamentally, we should learn about key programming concepts.

## 4.1 Conditional expressions

Conditional expressions are used for what is called flow control. The most common conditional expression is the if-else statement.
```{r}
a <- 0

if(a!=0){
  print(1/a)
} else{
  print("No reciprocal for 0.")
}
```

For example, pull the data of US murders:
```{r}
library(dslabs)
data(murders)
murder_rate <- murders$total / murders$population*100000
```

Using 'if' with a statement, we can run codes in '{}' if the statement is 'TRUE'. Otherwise Those in 'else{}' will be run:
```{r}
ind <- which.min(murder_rate)

if(murder_rate[ind] < 0.5){
  print(murders$state[ind]) 
} else{
  print("No state has murder rate that low")
}
```

We can change the statement:
```{r}
if(murder_rate[ind] < 0.25){
  print(murders$state[ind]) 
} else{
  print("No state has a murder rate that low.")
}
```

When you use 'ifelse' with a statement, the second argument will be run, if the statement was 'TRUE'. Otherwise, the third argument will be run:
```{r}
a <- 0
ifelse(a > 0, 1/a, NA)
```

If we put a vector in 'if' statement, each of elements in vectors are checked whether the element satisfies the statement.
```{r}
a <- c(0,1,2,-4,5)
result <- ifelse(a > 0, 1/a, NA)
```

For example, we can replace NA into 0:
```{r}
data(na_example)
no_nas <- ifelse(is.na(na_example), 0, na_example) 
sum(is.na(no_nas))
```

The function 'any' checks logical vector and return 'TRUE' if there 'TRUE' is, otherwise return 'FALSE'.
And the function 'all' checks logical vector and return 'FALSE' if there 'FALSE' is, otherwise return 'TRUE'.
```{r}
z <- c(TRUE, TRUE, FALSE)
any(z)
all(z)
```

## 4.2 Defining functions

There is so many of ready-made functions. But if there is no function we want, we can define new functions.
```{r}
avg <- function(x){
  s <- sum(x)
  n <- length(x)
  s/n
}
```

And this function can calulate the mean:
```{r}
x <- 1:100
identical(mean(x), avg(x))
```

If you run a function, variables defind inside the function cannot use outside the function. For example:
```{r}
s <- 3
avg(1:10)
s
```
We use 's' in function 'avg', but that cannot affect 's' of outside of the function.

In general, we can define our own functions for this form below.
```{r}
# my_function <- function(VARIABLE_NAME){
#   perform operations on VARIABLE_NAME and calculate VALUE
#   VALUE
# }
```

And we can get more than two arguments for a function.
```{r}
avg <- function(x, arithmetic = TRUE){
  n <- length(x)
  ifelse(arithmetic, sum(x)/n, prod(x)^(1/n))
}
```

## 4.3 Namespaces

If we load add-ons to coding, it can occur that functions from several add-ons are called by same name.
For example, 'dplyr' and 'stats' have function called 'filter' both. If we enter only 'filter', computers confused and cannot tell the function came from 'dplyr' or 'stats'.
But the two functions are leave in different namespace. For example:
```{r}
library(tidyverse)
search()
```
we can find packages we use in the global environment.

If we want to use the function from stats, we should use double colons '::':
```{r}
stats::filter
```

And we want to use the function from dplyr:
```{r}
dplyr::filter
```

## 4.4 For-loops

We can calculate ther series of natural numbers upto n:
```{r}
compute_s_n <- function(n){
  x <- 1:n
  sum(x)
}
```

We can repeat same code with just changing the value in the variables by using 'for' statements. For example:
```{r}
for(i in 1:5){
  print(i)
}
```

Using this, we can get the value of series of natural numbers.
```{r}
m <- 25
s_n <- vector(length = m) # create an empty vector
for(n in 1:m){
  s_n[n] <- compute_s_n(n)
}
```

We can create a plot of the serieses:
```{r}
n <- 1:m
plot(n, s_n)
```

It seems quadratic sequence, and S_n = n(n+s)/2 in fact:
```{r}
head(data.frame(s_n = s_n, formula = n*(n+1)/2))
```

We can plot S_n and line with function 'lines' of the equation:
```{r}
plot(n, s_n)
lines(n, n*(n+1)/2)
```
Those look identical.

## 4.5 Vectorization and functionals

For-Loop statement is useful definitely, but we rarely use it in R. We can make values for loops into a vector. We call it 'vectorization':
```{r}
x <- 1:10
sqrt(x)
y <- 1:10
x*y
```

However, if we use function, there is functions do not work well when we enter a vector. Like this:
```{r}
n <- 1:25
compute_s_n(n)
```

In the case, we can use function 'sapply' we can perform the function we want elementwise:
```{r}
x <- 1:10
sapply(x, sqrt)
```

Finally, we can rewrite the code above that calculate series of natural numbers like this:
```{r}
n <- 1:25
s_n <- sapply(n, compute_s_n)
plot(n, s_n)
```

## 4.6 Exercises

1. What will this conditional expression return?
```{r}
x <- c(1,2,-3,4)

if(all(x>0)){
  print("All Postives")
} else{
  print("Not all positives")
}
```
We would see "Not all positives".

2. Which of the following expressions is always 'FALSE' when at least one entry of a logical vector 'x' is 'TRUE'?

A. all(x)
:It's fales except that all elements of x are TRUE.
B. any(x)
:Because there must be TRUE at least one, it always returns TRUE.
C. any(!x)
:Because, in '!x', there must be FALSE at least one, it returns TRUE, except all elements of x are TRUE.
D. all(!x)
:Since there must be FALSE at least one in !x, it must return FALSE.


3. The function 'nchar' tells you how many characters long a character vector is.
Write a line of code that assigns to the object 'new_names' the state abbreviation when the state name is longer than 8 characters.
```{r}
new_names <- 0
for(i in 1:51){
  if(nchar(murders$state[i]) >= 8){
    new_names <- c(new_names, murders$abb[i])
  }
}
new_names
```

4. Create a function 'sum_n' that for any given value, say n, computes the sum of the integers from 1 to n (inclusive). Use the function to determine the sum of integers from 1 to 5,000.
```{r}
sum_n <- function(n){
  x <- 1:n
  sum(x)
}
x <- 1:5000
sapply(x, sum_n)
```
5. Create a function 'altman_plot' that takes two arguments, 'x' and 'y', and plots the difference against the sum.
```{r}
altman_plot <- function(x, y){
  plot(x+y, abs(x-y))
}
altman_plot(5,6)
```

6. After running the code below, what is the value of 'x'?
```{r}
x <- 3
my_func <- function(y){
  x <- 5
  y+5
}
```
It's 3 because the variables inside of the function cannot affect outside of the function and used only inside of that.

7. Write a function 'compute_s_n' that for any given n computes the sum S_n=1^2+2^2+3^2+…n^2. Report the value of the sum when  
n=10.
```{r}
compute_s_n <- function(n){
  x <- 1:n
  sum(x^2)
}
compute_s_n(10)
```

8. Define an empty numerical vector 's_n' of size 25 using 's_n <- vector("numeric", 25)' and store in the results of S_1, S_2, … S_25 using a for-loop.
```{r}
s_n <- vector("numeric", 25)

for(i in 1:25){
  s_n[i] <- compute_s_n(i)
}
s_n
```

9. Repeat exercise 8, but this time use 'sapply'.
```{r}
s_n <- sapply(1:25, compute_s_n)
s_n
```

10. Repeat exercise 8, but this time use 'map_dbl'.
```{r}
s_n <- map_dbl(1:25, compute_s_n)
s_n
```

11. Plot S_n versus n. Use points defined by n=1, …, 25.
```{r}
plot(1:25, s_n)
```

12. Confirm that the formula for this sum is S_n=n(n+1)(2n+1)/6.
```{r}
n <- 1:25
plot(n, s_n)
lines(n, n*(n+1)*(2*n+1)/6)
```
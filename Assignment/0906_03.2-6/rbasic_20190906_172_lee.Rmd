---
title: "R Basics"
output: html_document
---

# 3 R Basics

## 3.2 The very basics

### 3.2.1 Objects

We can store some stuff in R. We call it 'object' and we can use them similiar to how we do in math.
For example, we can simplify equations as a form like ax^2+bx+c=0. If we are given a equation x^2+x-1=0, then we define with the sign "<-" like:

```{r}
a <- 1
b <- 1
c <- -1
```

And we can check the value stored in 'a' by typing:

```{r}
a
```

Or, we can print it by typing:

```{r}
print(a)
```

### 3.2.2. The workspace

We can change our 'workspace' by defining objects and see all the variables saved in by typing:

```{r}
ls()
```

We can find a, b, and c. We've entered the values in the variables before, we can get a solution with the quadratic formula:
```{r}
(-b + sqrt(b^2 - 4*a*c) ) / ( 2*a )
(-b - sqrt(b^2 - 4*a*c) ) / ( 2*a )
```

### 3.2.3. Functions

After we define variables, we can use functions to analize and process the values.

There is functions that do not need any arguments like "ls()" or do need one or more argument like:
```{r}
log(8)
log(a)
```

If you are not familiar of some function, you can get some help from manuals:
```{r}
help("log")
```
or
```{r}
?log
```

We can find "Help" window at right below. The function "log" needs "x" and "base" If you want to find the arguments of some function:
```{r}
args(log)
```

You can change the default values by simply assigning another object:
```{r}
log(8, base = 2)
```

Note that we have not been specifying the argument x as such:
```{r}
log(x = 8, base = 2)
```

If we do not use argument name, the arguments entered are used in the order in which they are prescribed at "args":
```{r}
log(8,2)
```

If we use it, arguments are enterde in the order specified. At this time, you cannot use "<-", must use "=":
```{r}
log(base = 2, x = 8)
```

And there is common arithemetric or relational operators like:
```{R}
2^3
```
You can find out about arithmetic operator at here:
```{r}
help("+")
```
or
```{r}
?"+"
```
And about relational operator at here:
```{r}
help(">")
```
or
```{r}
?">"
```

### 3.2.4. Other prebuilt objects

We can see all the avaliable datasets by typing:
```{r}
data()
```

And at that list, we can select and use by typeing the name.
```{r}
co2
```

There is other prebuilt objects like mathematical quantities like pi and infinity:
```{r}
pi
Inf+1
```

### 3.2.5. Variable names

We can name our variables, but we should start name with a letter and cannot contain space, use predefined name.
```{r}
solution_1 <- (-b + sqrt(b^2 - 4*a*c)) / (2*a)
solution_2 <- (-b - sqrt(b^2 - 4*a*c)) / (2*a)
```

### 3.2.6. Saving your workspace

If we use "rm", we can erase everything on the workspace. Or when you quit R, you can save that.
You can use function "save", "save.image", and "load", but RStudio has beautiful GUI.

### 3.2.7. Motivating scripts

To solve another equation 3x^2+2x-1=0, we can use code above:
```{r}
a <- 3
b <- 2
c <- -1
(-b + sqrt(b^2 - 4*a*c)) / (2*a)
(-b - sqrt(b^2 - 4*a*c)) / (2*a)
```

### 3.2.8 Commenting your code

When you type a "#" in front of a comment that is not a source code, it would be excluded from program running

```{r}
## Code to compute solution to quadratic equation of the form ax^2 + bx + c
## define the variables
a <- 3 
b <- 2
c <- -1

## now compute the solution
(-b + sqrt(b^2 - 4*a*c)) / (2*a)
(-b - sqrt(b^2 - 4*a*c)) / (2*a)
```

## 3.3 Exercises

1. What is the sum of the firest 100 positive intgers? The formula for the sum of intgers 1 through n is n(n+1)/2. Define n=100 and the use R to complete the sum of 1 through 100 using the formula. What is the sum?
```{r}
n <- 100
ans <- n * (n+1) / 2

ans
## [1] 5050
## The answer is 5050
```

2. Now use the same formula to compute the sum of the integers from 1 through 1,000.
```{r}
n <- 1000
ans <- n * (n+1) / 2

ans
## [1] 500500
## The answer is 500500
```

3. Look at the result of typing the following code into R:
```{r}
n <- 1000
x <- seq(1, n)
sum(x)
```
Based on the result, what do you think the functions seq and sum do? You can use the help system:

B. seq creates a list of numbers and sum adds them up.

4.In math and programming, we say that we evaluate a function when we replace the argument with a given number. So if we type sqrt(4), we evaluate the sqrt function. In R, you can evaluate a function inside another function. The evaluations happen from the inside out. Use one line of code to compute the log, in base 10, of the square root of 100.
```{r}
log(sqrt(100), 10)
## [1] 1
## The answer is 1
```

5. Which of the following will always return the numeric value stored in x? You can try out examples and use the help system if you want.
```{r}
x = 1
log(10^x)
log10(x^10)
log(exp(x))
exp(log(x, base = 2))
#[1] 2.302585
#[1] 0
#[1] 1
#[1] 1

x = 2
log(10^x)
log10(x^10)
log(exp(x))
exp(log(x, base = 2))
#[1] 4.60517
#[1] 3.0103
#[1] 2
#[1] 2.718282

x = 3
log(10^x)
log10(x^10)
log(exp(x))
exp(log(x, base = 2))
#[1] 6.907755
#[1] 4.771213
#[1] 3
#[1] 4.879108

## The answer is C
```

## 3.4 Data types

Variables in R can be of different types. We can find out that with function "class":
```{r}
a <- 2
class(a)
```

## 3.5 Data frames
We used a variable with a data type. But we can combine different data types into one object. We call it 'Data frame'
We use data called 'murders' from 'dslabs' library
```{r}
library(dslabs)
data(murders)
```

And the type of that object is:
```{r}
class(murders)
#> [1] "data.frame"
```

### 3.5.1 Examining an object
The function "str" is for finding full structure of an object:
```{r}
str(murders)
```

We can only find out the values in the object with the function head:
```{r}
head(murders)
```

### 3.5.2 The accessor $
If we need only values of one column, we use the accessor operator $:
```{r}
murders$population
```

When we want to find what kinds of data are stored in the object, we can use the function "names":
```{r}
names(murders)
```

### 3.5.3 Vectors
Any objects that contain one or more values are called vectors. And we call how many data the vector contains as length. We can find it with function length:
```{R}
pop <- murders$population
length(pop)
```

This particular vector is numeric since population sizes are numbers:
```{r}
class(pop)
```
In a numeric vector, every entry must be a number.

To store character strings, vectors can also be of class character.
```{r}
class(murders$state)
```

If all components of a vector are either "TRUE" or "FALSE", that vector classified as logical vector:
```{r}
z <- 3 == 2
z
#> [1] FALSE
class(z)
```

"==" is relational operator about whether the value of left and right is same(TRUE) or not(FALSE)
```{r}
?Comparison
```

* if we use as.intger() or add L behind of an intger, the class changes from numeric into intger.

### 3.5.4 Factors

In the dataset 'murders', the class of vector 'region' is:
```{r}
class(murders$region)
#> [1] "factor"
```
a factor.

Factor vector stores categorical datas, like region vector. It contains only 4 regions by using the function 'levels':
```{r}
levels(murders$region)
```

At factor vector, R stores data as intgers with labels. The levels are ordered to alphabetical order, but we can rearrange it with function reorder:
```{r}
region <- murders$region
value <- murders$total
region <- reorder(region, value, FUN = sum)
levels(region)
```

### 3.5.5. Lists

List can store any combination of different types. We do not need variable names to find out the value.
Since data frames are a type of list, we can use accessor $ or just use double brackets.

### 3.5.6 Matrices

Matrix is 2-dimentional data type of storing numerical data.
We can perform numeric algebra operations with matrixes.

We can make a matrix with function 'matrix':
```{r}
mat <- matrix(1:12, 4, 3)
mat
```

We can access specific data with square brackets ([ ]):
```{r}
mat[2, 3]
```

If we want to use one row:
```{r}
mat[2, ]
```
And it returns a vector.

Similarly, if we want to use one column:
```{r}
mat[ ,3]
```

We can access to data as a matrix:
```{r}
mat[ , 2:3]
```

And also we can select start and final:
```{r}
mat[1:2, 2:3]
```

We can use it at data frame:
```{r}
data("murders")
murders[25, 1]
murders[2:3, ]
```

## 3.6 Exercises

1.Load the US murders dataset.
```{r}
library(dslabs)
data(murders)
```
Use the function str to examine the structure of the murders object. We can see that this object is a data frame with 51 rows and five columns. Which of the following best describes the variables represented in this data frame?
```{r}
str(murders)
#'data.frame':	51 obs. of  5 variables:
# $ state     : chr  "Alabama" ...
# $ abb       : chr  "AL"...
# $ region    : Factor w/ 4 levels "Northeast",..: 2 ...
# $ population: num  4779736 ...
# $ total     : num  135 ...
```
C. The state name, the abbreviation of the state name, the state’s region, and the state’s population and total number of murders for 2010.

2. What are the column names used by the data frame for these five variables?
```{r}
names(murders)
```
"state" "abb" "region" population" "total"

3. Use the accessor $ to extract the state abbreviations and assign them to the object a. What is the class of this object?
```{r}
a = murders$abb
class(a)
```
"character"

4. Now use the square brackets to extract the state abbreviations and assign them to the object b. Use the identical function to determine if a and b are the same.
```{r}
b = murders[2]
a == b
```
Yes, they are identical.

5. We saw that the region column stores a factor. You can corroborate this by typing:
```{r}
class(murders$region)
```
With one line of code, use the function levels and length to determine the number of regions defined by this dataset.
```{r}
length(levels(murders$region))
```
It is 4.

6. The function table takes a vector and returns the frequency of each element. You can quickly see how many states are in each region by applying this function. Use this function in one line of code to create a table of states per region.
```{r}
table(murders$region)
```
Northeast South North Central West
        9    17            12   13

